{"problem_id": 93, "problem": "eat", "method": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n    Have fun :)\n    \"\"\"\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]", "tests": [{"test_id": "1158", "test": "def test():\n        assert eat(4, 5, 1) == [5, 0], \"Error\"", "coverage_executed": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n\n>     else:\n>         return [ number + remaining , 0]", "coverage": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n!         return [ number + need , remaining-need ]\n>     else:\n>         return [ number + remaining , 0]", "coverage_sequence": [">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", "!", ">", ">"], "branch_sequence": ["?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", ">", "!", ">", ">"]}, {"test_id": "1153", "test": "def test():\n        assert eat(4, 8, 9) == [12, 1], \"Error\"", "coverage_executed": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n>         return [ number + need , remaining-need ]\n\n", "coverage": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n>         return [ number + need , remaining-need ]\n!     else:\n!         return [ number + remaining , 0]", "coverage_sequence": [">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", "!", "!"], "branch_sequence": ["?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", ">", ">", "!", "!"]}, {"test_id": "1152", "test": "def test():\n        assert eat(5, 6, 10) == [11, 4], \"Error\"", "coverage_executed": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n>         return [ number + need , remaining-need ]\n\n", "coverage": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n>         return [ number + need , remaining-need ]\n!     else:\n!         return [ number + remaining , 0]", "coverage_sequence": [">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", "!", "!"], "branch_sequence": ["?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", ">", ">", "!", "!"]}, {"test_id": "1151", "test": "def test():\n        assert True, \"This prints if this assert fails 1 (good for debugging!)\"", "coverage_executed": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n\n\n\n", "coverage": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n!     if(need <= remaining):\n!         return [ number + need , remaining-need ]\n!     else:\n!         return [ number + remaining , 0]", "coverage_sequence": [">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", "!", "!", "!", "!"], "branch_sequence": ["?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "!", "!", "!", "!"]}, {"test_id": "1155", "test": "def test():\n        assert eat(2, 11, 5) == [7, 0], \"Error\"", "coverage_executed": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n\n>     else:\n>         return [ number + remaining , 0]", "coverage": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n!         return [ number + need , remaining-need ]\n>     else:\n>         return [ number + remaining , 0]", "coverage_sequence": [">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", "!", ">", ">"], "branch_sequence": ["?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", ">", "!", ">", ">"]}, {"test_id": "1154", "test": "def test():\n        assert eat(1, 10, 10) == [11, 0], \"Error\"", "coverage_executed": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n>         return [ number + need , remaining-need ]\n\n", "coverage": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n>         return [ number + need , remaining-need ]\n!     else:\n!         return [ number + remaining , 0]", "coverage_sequence": [">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", "!", "!"], "branch_sequence": ["?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", ">", ">", "!", "!"]}, {"test_id": "1156", "test": "def test():\n        assert True, \"This prints if this assert fails 2 (also good for debugging!)\"", "coverage_executed": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n\n\n\n", "coverage": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n!     if(need <= remaining):\n!         return [ number + need , remaining-need ]\n!     else:\n!         return [ number + remaining , 0]", "coverage_sequence": [">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", "!", "!", "!", "!"], "branch_sequence": ["?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "!", "!", "!", "!"]}, {"test_id": "1157", "test": "def test():\n        assert eat(4, 5, 7) == [9, 2], \"Error\"", "coverage_executed": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n>         return [ number + need , remaining-need ]\n\n", "coverage": "> def eat(number, need, remaining):\n>     \"\"\"\n>     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n>     but now you need to eat more carrots to complete the day's meals.\n>     you should return an array of [ total number of eaten carrots after your meals,\n>                                     the number of carrots left after your meals ]\n>     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n>     Example:\n>     * eat(5, 6, 10) -> [11, 4]\n>     * eat(4, 8, 9) -> [12, 1]\n>     * eat(1, 10, 10) -> [11, 0]\n>     * eat(2, 11, 5) -> [7, 0]\n>     Variables:\n>     @number : integer\n>         the number of carrots that you have eaten.\n>     @need : integer\n>         the number of carrots that you need to eat.\n>     @remaining : integer\n>         the number of remaining carrots thet exist in stock\n>     Constrain:\n>     * 0 <= number <= 1000\n>     * 0 <= need <= 1000\n>     * 0 <= remaining <= 1000\n>     Have fun :)\n>     \"\"\"\n>     if(need <= remaining):\n>         return [ number + need , remaining-need ]\n!     else:\n!         return [ number + remaining , 0]", "coverage_sequence": [">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", ">", "!", "!"], "branch_sequence": ["?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", "?", ">", ">", "!", "!"]}]}